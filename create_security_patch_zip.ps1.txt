# PowerShell script: create_security_patch_zip.ps1
$OutZip = Join-Path $PWD "security_patch.zip"
$WorkDir = Join-Path $PWD ("security_patch_tmp_" + ([System.Guid]::NewGuid().ToString()))
if (Test-Path $WorkDir) { Remove-Item $WorkDir -Recurse -Force }
New-Item -ItemType Directory -Path $WorkDir | Out-Null
New-Item -ItemType Directory -Path (Join-Path $WorkDir "utils") | Out-Null
New-Item -ItemType Directory -Path (Join-Path $WorkDir "middleware") | Out-Null
New-Item -ItemType Directory -Path (Join-Path $WorkDir "models") | Out-Null
New-Item -ItemType Directory -Path (Join-Path $WorkDir "routes") | Out-Null

Set-Content -Path (Join-Path $WorkDir ".env.example") -Value @'
# .env.example
# احفظ هذا في .env على جهازك المحلي (ولا ترفع .env إلى git)
MONGO_URI=mongodb+srv://...
JWT_SECRET=replace_with_strong_jwt_secret
FIELD_ENCRYPTION_KEY=GENERATE_64_HEX_CHARS # 32 bytes hex -> استخدام لتشفير الحقول
ALLOWED_ORIGINS=https://your-domain.com,https://app.your-domain.com
CLOUDINARY_CLOUD_NAME=...
CLOUDINARY_API_KEY=...
CLOUDINARY_API_SECRET=...
NODE_ENV=development
PORT=3000
TRUST_PROXY=false

# لتوليد مفتاح تشفير آمن:
# node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
'@

Set-Content -Path (Join-Path $WorkDir "utils\field-encryption.js") -Value @'
const crypto = require('crypto');
const ALGO = 'aes-256-gcm';
const KEY_HEX = process.env.FIELD_ENCRYPTION_KEY;
if (!KEY_HEX) throw new Error('Missing FIELD_ENCRYPTION_KEY env var');
const KEY = Buffer.from(KEY_HEX, 'hex'); // 32 bytes

function encrypt(text) {
  if (text == null) return text;
  const iv = crypto.randomBytes(12); // 96-bit iv for GCM
  const cipher = crypto.createCipheriv(ALGO, KEY, iv);
  const encrypted = Buffer.concat([cipher.update(String(text), 'utf8'), cipher.final()]);
  const tag = cipher.getAuthTag();
  // iv:encrypted:tag, كل جزء في hex
  return `${iv.toString('hex')}:${encrypted.toString('hex')}:${tag.toString('hex')}`;
}

function decrypt(payload) {
  if (!payload) return payload;
  const [ivHex, encryptedHex, tagHex] = payload.split(':');
  if (!ivHex || !encryptedHex || !tagHex) return null;
  const iv = Buffer.from(ivHex, 'hex');
  const encrypted = Buffer.from(encryptedHex, 'hex');
  const tag = Buffer.from(tagHex, 'hex');
  const decipher = crypto.createDecipheriv(ALGO, KEY, iv);
  decipher.setAuthTag(tag);
  const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
  return decrypted.toString('utf8');
}

module.exports = { encrypt, decrypt };
'@

Set-Content -Path (Join-Path $WorkDir "middleware\auth-middleware.js") -Value @'
const jwt = require('jsonwebtoken');

module.exports = function(req, res, next) {
  try {
    const authHeader = req.headers.authorization || '';
    // نحاول أخذ التوكن من Authorization header أو من الكوكي
    const token = authHeader.startsWith('Bearer ') ? authHeader.split(' ')[1] : (req.cookies && req.cookies.token);
    if (!token) return res.status(401).json({ message: 'Unauthorized' });

    const payload = jwt.verify(token, process.env.JWT_SECRET);
    req.user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Invalid or expired token' });
  }
};

// ملاحظة: تأكد أن JWT_SECRET مضبوط في بيئتك/Secret Manager
'@

Set-Content -Path (Join-Path $WorkDir "security.js") -Value @'
require('dotenv').config();
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');
const cookieParser = require('cookie-parser');
const express = require('express');

module.exports = function applySecurity(app) {
  // اعتمادًا على env، قد تحتاج لتمكين trust proxy
  if (String(process.env.TRUST_PROXY || '').toLowerCase() === 'true' ||
      process.env.TRUST_PROXY === '1') {
    app.set('trust proxy', 1);
  }

  // Helmet - رؤوس أمان HTTP
  app.use(helmet());

  // Content Security Policy - قاعدة أساسية، عدّل المصادر حسب الحاجة
  try {
    app.use(
      helmet.contentSecurityPolicy({
        useDefaults: true,
        directives: {
          "script-src": ["'self'", "'unsafe-inline'"], // قلّل 'unsafe-inline' في الإنتاج إن أمكن
          "img-src": ["'self'", "data:", "https:"],
          "connect-src": ["'self'", "https:"],
        },
      })
    );
  } catch (e) {
    // بعض إصدارات helmet تتطلب خيارات خاصة؛ إذا واجهت مشكلة تخلص من CSP هنا مؤقتًا
    console.warn('CSP init warning', e && e.message);
  }

  // Body parsers مع حدود
  app.use(express.json({ limit: '10kb' }));
  app.use(express.urlencoded({ extended: true, limit: '10kb' }));
  app.use(cookieParser());

  // تنظيف للـ NoSQL Injection
  app.use(mongoSanitize());

  // تنظيف XSS
  app.use(xss());

  // منع HTTP Parameter Pollution
  app.use(hpp());

  // CORS صارمة
  const allowedOrigins = (process.env.ALLOWED_ORIGINS || '')
    .split(',')
    .map(o => o.trim())
    .filter(Boolean);

  const corsOptions = {
    origin: function(origin, callback) {
      // السماح بالطلبات بدون origin (curl/postman)، غيّر هذا إذا أردت رفضها
      if (!origin) return callback(null, true);
      if (allowedOrigins.indexOf(origin) !== -1) return callback(null, true);
      return callback(new Error('Not allowed by CORS'));
    },
    credentials: true,
    methods: ['GET','POST','PUT','DELETE','OPTIONS'],
    allowedHeaders: ['Content-Type','Authorization']
  };

  app.use(cors(corsOptions));

  // Rate limiting عام
  const generalLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 200,
    standardHeaders: true,
    legacyHeaders: false
  });
  app.use(generalLimiter);

  // HSTS و إعدادات إضافية عبر Helmet
  try {
    app.use(helmet.hsts({ maxAge: 90 * 24 * 60 * 60, includeSubDomains: true, preload: true }));
  } catch (e) {
    console.warn('HSTS init warning', e && e.message);
  }

  // ملاحظة: auth-specific rate limiter يُطبّق داخل routes/auth.js
};
'@

Set-Content -Path (Join-Path $WorkDir "models\User.js") -Value @'
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const { encrypt, decrypt } = require('../utils/field-encryption');

const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true, lowercase: true, trim: true },
  password: { type: String, required: true, select: false },
  phoneEncrypted: { type: String, select: false },
  // أي حقول حساسة أخرى يمكنك إضافتها أيضًا
}, {
  timestamps: true,
  toJSON: { getters: true },
  toObject: { getters: true }
});

// virtual لحقل phone ليظهر مفكوك التشفير عند toObject/toJSON
userSchema.virtual('phone')
  .get(function() {
    if (!this.phoneEncrypted) return undefined;
    try { return decrypt(this.phoneEncrypted); } catch (e) { return undefined; }
  })
  .set(function(plain) {
    this.phoneEncrypted = plain ? encrypt(plain) : undefined;
  });

// Hash password
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  const salt = await bcrypt.genSalt(12);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

userSchema.methods.comparePassword = async function(plain) {
  return bcrypt.compare(plain, this.password);
};

module.exports = mongoose.model('User', userSchema);
'@

Set-Content -Path (Join-Path $WorkDir "routes\auth.js") -Value @'
const express = require('express');
const { body, validationResult } = require('express-validator');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const rateLimit = require('express-rate-limit');

const router = express.Router();

function handleValidationErrors(req, res, next) {
  const errors = validationResult(req);
  if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });
  next();
}

// auth-specific rate limiter (apply to this router)
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 8,
  message: 'Too many auth attempts from this IP, please try again later',
  standardHeaders: true,
  legacyHeaders: false
});
router.use(authLimiter);

// Register
router.post('/register', [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }),
  body('phone').optional().trim().escape()
], handleValidationErrors, async (req, res) => {
  try {
    const { email, password, phone } = req.body;
    const exists = await User.findOne({ email });
    if (exists) return res.status(409).json({ message: 'Email already registered' });

    const user = new User({ email, password });
    if (phone) user.phone = phone; // virtual setter encrypts
    await user.save();
    res.status(201).json({ message: 'User created' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
});

// Login
router.post('/login', [
  body('email').isEmail().normalizeEmail(),
  body('password').exists()
], handleValidationErrors, async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email }).select('+password');
    if (!user) return res.status(401).json({ message: 'Invalid credentials' });

    const ok = await user.comparePassword(password);
    if (!ok) return res.status(401).json({ message: 'Invalid credentials' });

    const token = jwt.sign({ sub: user._id, email: user.email }, process.env.JWT_SECRET, { expiresIn: '1h' });
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'Strict',
      maxAge: 60 * 60 * 1000
    });
    res.json({ token });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;
'@

Set-Content -Path (Join-Path $WorkDir "SECURITY_PATCH_INSTRUCTIONS.md") -Value @'
# SECURITY_PATCH_INSTRUCTIONS.md

ملف هذا الـ patch يضيف ملفات أمان مهمة. فيما يلي تعليمات الدمج السريعة مع `server.js` القائم لديك:

1. إنشاء فرع:

```bash
git checkout -b security/hardening